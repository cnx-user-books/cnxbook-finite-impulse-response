<document xmlns="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml">
    <title>Linear Assembly Implementation of FIR Filters on TMS320C62x</title>
    <metadata><md:content-id>undefined</md:content-id><md:title/><md:uuid>2bd54ddd-85c1-43b9-b600-aaf14d8915c7</md:uuid>
</metadata>



    <content>
      <section id="sec1">
	<title>FIR Filter Implementation in TI Linear Assembly</title>
	<section id="subsec1">
	  <title>What is Linear Assembly?</title>
	  <para id="p1">
	    TI's linear assembly language enables you to write an assembly-like
	    programs without worrying about register usage, pipelining, delay
	    slots, etc. The assembler optimizer program reads the linear
	    assembly code to figure out the algorithm, and then it produces
	    an optimized list of assembly code to perform the operations.
	    The linear assembly programming lets you:
	    <list id="lst1">
	      <item>use symbolic names,</item>
	      <item>forget pipeline issues,</item>
	      <item>ignore putting NOPs, parallel bars, functional units, register names,</item>
	      <item> more efficiently use CPU resources than C.</item>
	    </list>
	  </para>
	  <para id="p2">
	    The linear assembly files have <code>.sa</code>
	    extensions. When you have a linear assembly file in your
	    Code Composer Studio project, the assembly optimizer is
	    invoked automatically to generate optimized actual
	    assembly routine.  You can consider the linear assembly
	    language as a tool to describe algorithms. To effectively
	    convey the intent of the programmer to the assembly
	    optimizer for proper optimization, there are quite a few
	    extra directives in linear assembly.
	  </para>
	</section>
	<section id="subsec2">
	  <title>C callable Linear Assembly procedure</title>
	  <para id="p3">
	    The following is an example of C callable linear assembly
	    routine that computes the dot product of two vectors. It
	    implements a C function
	  </para>
	  <code display="block" id="idp2839664">
	    
	    short dotp(short* a, short* x, int count);
	    
	  </code>
	  <para id="p4">
	    If <code>a[]</code> and <code>x[]</code>
	    are two length-40 vectors, the C function call has the
	    form
	  </para>
	  <code display="block" id="idp295520">
	    
	    short a[];
	    short x[];
	    short z;
	    ...
	    ...
	    z = dotp(a,x,40);
	    ...
	    
	  </code>
	  <para id="p5">
	    (see below how the arguments are passed and the pointers are used.)
	    In the following, you learn various assembler directives
	    used below and how the optimized 
	    assembly code is generated by the assembler optimizer.
	  </para>
	  <code display="block" id="idp2739984">
	    
	    _dotp:  .cproc  ap,xp,cnt
	    .reg    a,x,prod,y

	    MVK     40,cnt
	    loop:   .trip 40
	    LDH     *ap++,a
	    LDH     *ax++,x
	    MPY     a,x,prod
	    ADD     y,prod,y
	    SUB     cnt,1,cnt
	    [cnt]   B       loop

	    .return         y
	    .endproc
	    
	  </code>
	  <para id="p6">
	    The <code>.cproc</code> directive starts a C callable
	    procedure. It must be used with <code>.endproc</code> to
	    end a C procedure. <code>_dotp:</code> is the label used
	    to name the procedure. By using <code>.cproc</code> to
	    start the procedure, the assembly optimizer performs some
	    operations automatically in a <code>.cproc</code> region
	    in order to make the function conform to the C calling
	    conventions and to C register usage convention. The
	    following optional variables (<code>ap,xp,cnt</code>
	    above) represent function parameters. The variable entries
	    are very similar to parameters declared in a C function.
	  </para>
	  <para id="p7">
	    The arguments to the <code>.cproc</code> directive can be
	    either machine-register names or symbolic names.  When
	    register names are specified, its position in the argument
	    list must correspond to the argument passing conventions
	    for C. For example, the first argument in C function must
	    be register A4. When symbolic names are specified, the
	    assembly optimizer ensures proper allocation and
	    initialization (if necessary) of registers at the
	    beginning of the procedure. To represent a 40-bit
	    argument, a register pair can be specified as an
	    argument. In this lab, however, we only use 32bit values
	    as arguments.
	  </para>
	  <para id="p8">
	    The <code>.reg</code> directive allows you to use descriptive
	    names for values that will be stored in registers. It is
	    valid only within procedures only.
	  </para>
	  <para id="p9">
	    The <code>.return</code> directive functionality is
	    equivalent to the return statement in C code. It places
	    the optional argument in the appropriate register for a
	    return value as per the C calling conventions. If no
	    argument is specified, no value is returned, similar to a
	    <code>void</code> function in C code.  To perform a
	    conditional <code>.return</code>, you can simply put
	    conditional branch around a <code>.return</code> as:
	  </para>
	  <code display="block" id="idp497696">
	    
	    [!cc]   B   around
	    .return
	    around:
	    
	  </code>
	  <para id="p10">
	    The <code>.trip</code> directive specifies the value of
	    the trip count. The <emphasis>trip count</emphasis>
	    indicates how many times a loop will iterate. By giving
	    this extra information to the assembler optimizer, a
	    better optimization is achieved for loops. The label
	    preceding <code>.trip</code> directive represents the
	    beginning of the loop. This is a required parameter.
	  </para>
	  <para id="p11">
	    For more information on writing C callable linear assembly
	    procedure, refer to <emphasis>TMS320C6x Optimizing C
	    Compiler User's Guide</emphasis>. For C6x assembly
	    instructions, refer to <emphasis>TMS320C62x/C67x CPU and
	    Instruction Set Reference Guide</emphasis>.
	  </para>
	</section>
	<exercise id="ex1">
	  <problem id="idp1100640">
	    <para id="p12">
	      Write a C callable FIR filtering routine in linear assembly.
	      When using different optimization levels, what is the number
	      of clock cycles of each FIR filtering?
	    </para>
	  </problem>
	  <solution id="idp832720">
	    <para id="p13"/>
	  </solution>
	</exercise>
      </section>
    </content>
    
  </document>